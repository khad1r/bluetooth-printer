class PrintBitmapData {
  constructor(printElement, thresholdMapIndex = 0, PAPER_WIDTH = 58) {
    this.thresholdMaps = [
      /** i don't know how to get one what is this, 
       * generated by ChatGPT but helped for making grayscale image
       * some of this like more darker or lighter
       * Try it YourSelf
       */
      [
        [0, 128, 32, 160],
        [192, 64, 224, 96],
        [48, 176, 16, 144],
        [240, 112, 208, 80]
      ],
      [
        [16, 144, 48, 176],
        [208, 80, 240, 112],
        [64, 192, 32, 160],
        [224, 96, 192, 64]
      ],
      [
        [32, 160, 64, 192],
        [224, 96, 240, 128],
        [80, 208, 48, 176],
        [240, 112, 208, 80]
      ],
      [
        [192, 224, 208, 240],
        [240, 176, 224, 192],
        [208, 240, 192, 224],
        [224, 192, 240, 208]
      ],
    ];
    this.thresholdMapIndex = thresholdMapIndex;
    this.canvasWidth = 0;
    this.canvasHeight = 0;
    this.imageData = null;

    const DPI = 203.2;
    const PAPER_WIDTH_MM = PAPER_WIDTH;
    const PADDING_MM = 5; // Assuming 5mm padding on each side

    // Calculate printable area width in pixels
    const PRINTABLE_WIDTH_MM = PAPER_WIDTH_MM - (2 * PADDING_MM);
    const canvasWidth = Math.round(DPI * (PRINTABLE_WIDTH_MM / 25.4/* inch to mm */));

    this.imgHTMLElement = new Image();
    this.canvasHTMLElement = document.createElement('canvas');
    // Convert to Bitmap
    this.imgHTMLElement.onload = () => {
      this.canvasHTMLElement.width = canvasWidth;
      this.canvasHTMLElement.height = this.imgHTMLElement.naturalHeight;
      let context = this.canvasHTMLElement.getContext('2d');
      context.drawImage(this.imgHTMLElement, 0, 0, this.canvasHTMLElement.width, this.canvasHTMLElement.height);
      this.imageData = context.getImageData(0, 0, this.canvasHTMLElement.width, this.canvasHTMLElement.height).data;
      this.canvasWidth = this.canvasHTMLElement.width;
      this.canvasHeight = this.canvasHTMLElement.height;
    };
    // check if is a Img or HTML Element
    if (printElement.tagName === "IMG") {
      this.imgHTMLElement.src = printElement.src;
    } else {
      domtoimage.toSvg(printElement, { width: canvasWidth })
        .then((dataUrl) => {
          this.imgHTMLElement.src = dataUrl;
        });
    }
  }
  _getDarkPixel(x, y) {
    // Return the pixels that will be printed black
    let red = this.imageData[((this.canvasWidth * y) + x) * 4];
    let green = this.imageData[((this.canvasWidth * y) + x) * 4 + 1];
    let blue = this.imageData[((this.canvasWidth * y) + x) * 4 + 2];
    return (red + green + blue) > 0 ? 1 : 0;
  }

  _getGrayPixel(x, y) {
    let red = this.imageData[((this.canvasWidth * y) + x) * 4];
    let green = this.imageData[((this.canvasWidth * y) + x) * 4 + 1];
    let blue = this.imageData[((this.canvasWidth * y) + x) * 4 + 2];
    let alpha = this.imageData[((this.canvasWidth * y) + x) * 4 + 3];
    if (alpha < 128) return 255;  // Treat transparent pixels as white
    return (red + green + blue) / 3;
  }
  /** Modified By ChatGPT  */
  _getDitheredPixel(x, y) {
    let gray = this._getGrayPixel(x, y);
    let threshold = this.thresholdMaps[this.thresholdMapIndex][y % 4][x % 4];
    return gray > threshold ? 0 : 1;
  }

  async getImagePrintData() {
    if (!this.imageData) {
      console.log('No image to print!');
      return new Uint8Array([]);
    }

    // Each 8 pixels in a row is represented by a byte
    let printData = new Uint8Array(this.canvasWidth / 8 * this.canvasHeight + 8);
    let offset = 0;
    // Set the header bytes for printing the image
    printData[0] = 29;  // Print raster bitmap
    printData[1] = 118; // Print raster bitmap
    printData[2] = 48; // Print raster bitmap
    printData[3] = 0;  // Normal 203.2 DPI
    printData[4] = this.canvasWidth / 8; // Number of horizontal data bits (LSB)
    printData[5] = 0; // Number of horizontal data bits (MSB)
    printData[6] = this.canvasHeight % 256; // Number of vertical data bits (LSB)
    printData[7] = Math.floor(this.canvasHeight / 256); // Number of vertical data bits (MSB)
    offset = 7;

    for (let i = 0; i < this.canvasHeight; ++i) {
      for (let k = 0; k < this.canvasWidth / 8; ++k) {
        let k8 = k * 8;
        printData[++offset] =
          this._getDitheredPixel(k8 + 0, i) * 128 + this._getDitheredPixel(k8 + 1, i) * 64 +
          this._getDitheredPixel(k8 + 2, i) * 32 + this._getDitheredPixel(k8 + 3, i) * 16 +
          this._getDitheredPixel(k8 + 4, i) * 8 + this._getDitheredPixel(k8 + 5, i) * 4 +
          this._getDitheredPixel(k8 + 6, i) * 2 + this._getDitheredPixel(k8 + 7, i);
      }
    }
    return printData;
  }
}
class ThermalPrinter {
  constructor() {
    this.printCharacteristic = null;
    this.printDevice = null;
    this.batchSize = 512; // Maximum bytes per write operation
  }

  async connect(cachedDevice = sessionStorage.getItem('printBTDevice')) {
    if (this.printCharacteristic) {
      console.log(`already Connected to printer ${this.printDevice.name}`);
      return;
    }
    try {
      let device;
      if (cachedDevice) {
        // check Session or passed params bluetooth devices
        Device = JSON.parse(cachedDevice);
        console.log(`Loaded cached ${device.name}`);
      } else if (this.printDevice !== null) {
        // check from this object
        Device = this.printDevice;
      } else {
        // or connect a new one
        device = await navigator.bluetooth.requestDevice({
          filters: [{ services: ['000018f0-0000-1000-8000-00805f9b34fb'] }]
        });
        console.log(`> Found ${device.name}`);
      }
      this.printDevice = device;
      // Connecting to the Device
      console.log('Connecting to GATT Server...');
      const server = await device.gatt.connect();
      server.device.addEventListener('gattserverdisconnected', this._Disconnected.bind(this));

      // getting the service function
      const service = await server.getPrimaryService("000018f0-0000-1000-8000-00805f9b34fb");
      this.printCharacteristic = await service.getCharacteristic("00002af1-0000-1000-8000-00805f9b34fb");

      console.log('Connected to printer');
      this.onConnected(this.printDevice);
    } catch (error) {
      // clear anything if error on connecting
      this.printCharacteristic = null;
      this.printDevice = null;
      sessionStorage.removeItem('printBTDevice');
      throw new Error(`Failed to connect to printer: ${error.message}`);
    }
  }

  _Disconnected(event) {
    console.log('Device disconnected');
    this.printCharacteristic = null;
    this.onDisconnected(this.printDevice);
  }

  storeDeviceToSession() {
    if (this.printCharacteristic) {
      sessionStorage.setItem('printBTDevice', this.Device);
      console.log('Stored bluetooth devices to session storage');
    }
  }

  async sendBatch(data) {
    // Can only write 512 bytes at a time to the characteristic
    // Need to send the image data in 512 byte batches
    if (!this.printCharacteristic) {
      throw new Error('Printer is not connected. Please connect to the printer first.');
    }

    let index = 0;
    const { batchSize, printCharacteristic } = this;

    const sendNextBatch = async () => {
      if (index >= data.length) return;
      const endIndex = Math.min(index + batchSize, data.length);
      const chunk = data.slice(index, endIndex);

      await printCharacteristic.writeValue(chunk);
      index = endIndex;
      return sendNextBatch();
    };

    try {
      await sendNextBatch();
    } catch (error) {
      throw new Error(`Failed to send data: ${error.message}`);
    }
  }

  async sendData(data) {
    try {
      await this.sendBatch(data);
      return { success: true, message: 'Data sent successfully' };
    } catch (error) {
      throw new Error(`Failed to send data: ${error.message}`);
    }
  }

  async sendImageData(imageData) {
    console.log(imageData);
    return this.sendData(imageData);
  }

  async sendTextData(message) {
    const encoder = new TextEncoder("utf-8");
    // Add line feed + carriage return chars to text
    const text = encoder.encode(message + '\u000A\u000D');
    return this.sendData(text);
  }
  // Overwrite this 2 function
  onConnected = () => { }
  onDisconnected = () => { }
}


module.exports = { PrintBitmapData, ThermalPrinter };
