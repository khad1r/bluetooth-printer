// class PrintBitmapData {
//   constructor(printElement, thresholdMapIndex = 0, PAPER_WIDTH = 58) {
//     this.thresholdMaps = [
//       /** i don't know how to get one what is this, 
//        * generated by ChatGPT but helped for making grayscale image
//        * some of this like more darker or lighter
//        * Try it YourSelf
//        */
//       [
//         [0, 128, 32, 160],
//         [192, 64, 224, 96],
//         [48, 176, 16, 144],
//         [240, 112, 208, 80]
//       ],
//       [
//         [16, 144, 48, 176],
//         [208, 80, 240, 112],
//         [64, 192, 32, 160],
//         [224, 96, 192, 64]
//       ],
//       [
//         [32, 160, 64, 192],
//         [224, 96, 240, 128],
//         [80, 208, 48, 176],
//         [240, 112, 208, 80]
//       ],
//       [
//         [192, 224, 208, 240],
//         [240, 176, 224, 192],
//         [208, 240, 192, 224],
//         [224, 192, 240, 208]
//       ],
//     ];
//     this.thresholdMapIndex = thresholdMapIndex;
//     this.canvasWidth = 0;
//     this.canvasHeight = 0;
//     this.imageData = null;

//     const DPI = 203.2;
//     const PAPER_WIDTH_MM = PAPER_WIDTH;
//     const PADDING_MM = 5; // Assuming 5mm padding on each side

//     // Calculate printable area width in pixels
//     const PRINTABLE_WIDTH_MM = PAPER_WIDTH_MM - (2 * PADDING_MM);
//     const canvasWidth = Math.round(DPI * (PRINTABLE_WIDTH_MM / 25.4/* inch to mm */));

//     this.imgHTMLElement = new Image();
//     this.canvasHTMLElement = document.createElement('canvas');
//     // Convert to Bitmap
//     this.imgHTMLElement.onload = () => {
//       this.canvasHTMLElement.width = canvasWidth;
//       this.canvasHTMLElement.height = this.imgHTMLElement.naturalHeight;
//       let context = this.canvasHTMLElement.getContext('2d');
//       context.drawImage(this.imgHTMLElement, 0, 0, this.canvasHTMLElement.width, this.canvasHTMLElement.height);
//       this.imageData = context.getImageData(0, 0, this.canvasHTMLElement.width, this.canvasHTMLElement.height).data;
//       this.canvasWidth = this.canvasHTMLElement.width;
//       this.canvasHeight = this.canvasHTMLElement.height;
//     };
//     // check if is a Img or HTML Element
//     if (printElement.tagName === "IMG") {
//       this.imgHTMLElement.src = printElement.src;
//     } else {
//       domtoimage.toSvg(printElement, { width: canvasWidth })
//         .then((dataUrl) => {
//           this.imgHTMLElement.src = dataUrl;
//         });
//     }
//   }
//   _getDarkPixel(x, y) {
//     // Return the pixels that will be printed black
//     let red = this.imageData[((this.canvasWidth * y) + x) * 4];
//     let green = this.imageData[((this.canvasWidth * y) + x) * 4 + 1];
//     let blue = this.imageData[((this.canvasWidth * y) + x) * 4 + 2];
//     return (red + green + blue) > 0 ? 1 : 0;
//   }

//   _getGrayPixel(x, y) {
//     let red = this.imageData[((this.canvasWidth * y) + x) * 4];
//     let green = this.imageData[((this.canvasWidth * y) + x) * 4 + 1];
//     let blue = this.imageData[((this.canvasWidth * y) + x) * 4 + 2];
//     let alpha = this.imageData[((this.canvasWidth * y) + x) * 4 + 3];
//     if (alpha < 128) return 255;  // Treat transparent pixels as white
//     return (red + green + blue) / 3;
//   }
//   /** Modified By ChatGPT  */
//   _getDitheredPixel(x, y) {
//     let gray = this._getGrayPixel(x, y);
//     let threshold = this.thresholdMaps[this.thresholdMapIndex][y % 4][x % 4];
//     return gray > threshold ? 0 : 1;
//   }

//   async getImagePrintData() {
//     if (!this.imageData) {
//       console.log('No image to print!');
//       return new Uint8Array([]);
//     }

//     // Each 8 pixels in a row is represented by a byte
//     let printData = new Uint8Array(this.canvasWidth / 8 * this.canvasHeight + 8);
//     let offset = 0;
//     // Set the header bytes for printing the image
//     printData[0] = 29;  // Print raster bitmap
//     printData[1] = 118; // Print raster bitmap
//     printData[2] = 48; // Print raster bitmap
//     printData[3] = 0;  // Normal 203.2 DPI
//     printData[4] = this.canvasWidth / 8; // Number of horizontal data bits (LSB)
//     printData[5] = 0; // Number of horizontal data bits (MSB)
//     printData[6] = this.canvasHeight % 256; // Number of vertical data bits (LSB)
//     printData[7] = Math.floor(this.canvasHeight / 256); // Number of vertical data bits (MSB)
//     offset = 7;

//     for (let i = 0; i < this.canvasHeight; ++i) {
//       for (let k = 0; k < this.canvasWidth / 8; ++k) {
//         let k8 = k * 8;
//         printData[++offset] =
//           this._getDitheredPixel(k8 + 0, i) * 128 + this._getDitheredPixel(k8 + 1, i) * 64 +
//           this._getDitheredPixel(k8 + 2, i) * 32 + this._getDitheredPixel(k8 + 3, i) * 16 +
//           this._getDitheredPixel(k8 + 4, i) * 8 + this._getDitheredPixel(k8 + 5, i) * 4 +
//           this._getDitheredPixel(k8 + 6, i) * 2 + this._getDitheredPixel(k8 + 7, i);
//       }
//     }
//     return printData;
//   }
// }
class ThermalPrinter {
  constructor() {
    this.printCharacteristic = null;
    this.printDevice = null;
    this.batchSize = 512; // Maximum bytes per write operation
  }

  async connect(cachedDevice = this.printDevice) {
    if (this.printCharacteristic) {
      console.log(`already Connected to printer ${this.printDevice.name}`);
      return;
    }
    try {
      let device = (!cachedDevice)
        ? await navigator.bluetooth.requestDevice({
          filters: [{ services: ['000018f0-0000-1000-8000-00805f9b34fb'] }]
        })
        : cachedDevice

      this.printDevice = device;

      // Check and remove existing event listeners
      device.removeEventListener('gattserverdisconnected', this._Disconnected.bind(this));
      device.removeEventListener('advertisementreceived', this._onAdvertisementReceived.bind(this));

      // Connecting to the Device
      console.log('Connecting to GATT Server...');
      const server = await device.gatt.connect();
      device.addEventListener('gattserverdisconnected', this._Disconnected.bind(this));
      device.addEventListener('advertisementreceived', this._onAdvertisementReceived.bind(this));

      // getting the service function
      const service = await server.getPrimaryService("000018f0-0000-1000-8000-00805f9b34fb");
      this.printCharacteristic = await service.getCharacteristic("00002af1-0000-1000-8000-00805f9b34fb");

      console.log('Connected to printer');
      this.onConnected(this.printDevice);
    } catch (error) {
      // clear anything if error on connecting
      this.printCharacteristic = null;
      this.printDevice = null;
      throw new Error(`Failed to connect to printer: ${error.message}`);
    }
  }
  _Disconnected(event) {
    console.log('Device disconnected');
    console.log(this.printDevice);
    this.printCharacteristic = null;
    this.onDisconnected(this.printDevice);
    this.printDevice.watchAdvertisements();
  }
  _onAdvertisementReceived(event) {
    console.log('> Received advertisement from "' + this.printDevice.name + '"...');
    this.printDevice.gatt.connect();
    // this.printDevice.unwatchAdvertisements();
  }

  async sendBatch(data) {
    // Can only write 512 bytes at a time to the characteristic
    // Need to send the image data in 512 byte batches
    if (!this.printCharacteristic) {
      throw new Error('Printer is not connected. Please connect to the printer first.');
    }

    let index = 0;
    const { batchSize, printCharacteristic } = this;

    const sendNextBatch = async () => {
      if (index >= data.length) return;
      const endIndex = Math.min(index + batchSize, data.length);
      const chunk = data.slice(index, endIndex);

      await printCharacteristic.writeValue(chunk);
      index = endIndex;
      return sendNextBatch();
    };
    await sendNextBatch();
  }

  async print(data) {
    try {
      await this.sendBatch(data);
      return { success: true, message: 'Data sent successfully' };
    } catch (error) {
      throw new Error(`Failed to send data: ${error.message}`);
    }
  }

  // async sendImageData(imageData) {
  //   console.log(imageData);
  //   return this.sendData(imageData);
  // }

  // async sendTextData(message) {
  //   const encoder = new TextEncoder("utf-8");
  //   // Add line feed + carriage return chars to text
  //   const text = encoder.encode(message + '\u000A\u000D');
  //   return this.sendData(text);
  // }
  // Overwrite this 2 function
  onConnected = () => { }
  onDisconnected = () => { }
}


module.exports = { PrintBitmapData, ThermalPrinter };
